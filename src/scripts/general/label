#!/usr/bin/python2
# -*- coding: utf-8; mode: Python; indent-tabs-mode: t; tab-width: 4; python-indent: 4 -*-

# Copyright (C) 2012  Olga Yakovleva <yakovleva.o.v@gmail.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import os
import os.path
import subprocess
import argparse
import re
import codecs
import itertools
import collections
import xml.etree.ElementTree as xml
from scipy import stats

def run(*args):
	subprocess.check_call(args,stdout=sys.stdout,stderr=sys.stderr)

def setup(args):
	os.mkdir("lab")
	os.mkdir("ehmm")
	for subdir in ["feat","mod","etc","lab"]:
		os.mkdir(os.path.join("ehmm",subdir))
		ehmm_settings=collections.OrderedDict()
	with codecs.open(os.path.join(args.ehmm_dir,"etc","mysp_settings"),"rb","utf-8") as f:
		for line in f:
			m=re.match(r"\s*(\S+)\s*:\s*(\S+)\s*",line)
			if m:
				ehmm_settings[m.group(1)]=m.group(2)
	ehmm_settings["WaveDir"]=args.wave_dir
	with codecs.open(os.path.join("ehmm","etc","mysp_settings"),"wb","utf-8") as f:
		for k,v in ehmm_settings.iteritems():
			f.write(u"{}: {}\n".format(k,v))

def phseq(args):
	work_dir=os.path.join("ehmm","etc")
	waves=sorted(name for name in os.listdir(args.wave_dir) if name.endswith(".wav"))
	with codecs.open(args.transcription,"rb","utf-8") as f_in:
		with codecs.open(os.path.join(work_dir,"txt.phseq.data"),"wb","utf-8") as f_out:
			for name,line in itertools.izip(waves,f_in):
				f_out.write(os.path.splitext(name)[0])
				f_out.write(" ")
				f_out.write(line.strip())
				f_out.write("\n")
	bin_dir=os.path.join(args.ehmm_dir,"bin")
	run("perl",os.path.join(bin_dir,"phfromutt.pl"),os.path.join(work_dir,"txt.phseq.data"),os.path.join(work_dir,"ph_list"),"5")
	run("perl",os.path.join(bin_dir,"getwavlist.pl"),os.path.join(work_dir,"txt.phseq.data"),os.path.join(work_dir,"mywavelist"))

def feats(args):
	bin_dir=os.path.join(args.ehmm_dir,"bin")
	work_dir=os.path.join("ehmm","etc")
	feat_dir=os.path.join("ehmm","feat")
	run(os.path.join(bin_dir,"FeatureExtraction"),os.path.join(work_dir,"mysp_settings"),os.path.join(work_dir,"mywavelist"))
	run("perl",os.path.join(bin_dir,"comp_dcep.pl"),os.path.join(work_dir,"mywavelist"),feat_dir,"mfcc","ft","0","0")
	run("perl",os.path.join(bin_dir,"scale_feat.pl"),os.path.join(work_dir,"mywavelist"),feat_dir,os.path.join("ehmm","mod"),"ft","4")
	run("perl",os.path.join(bin_dir,"seqproc.pl"),os.path.join(work_dir,"txt.phseq.data"),os.path.join(work_dir,"ph_list"),"2","2","13")

def bw(args):
	bin_dir=os.path.join(args.ehmm_dir,"bin")
	feat_dir=os.path.join("ehmm","feat")
	mod_dir=os.path.join("ehmm","mod")
	work_dir=os.path.join("ehmm","etc")
	run(os.path.join(bin_dir,"ehmm"),os.path.join(work_dir,"ph_list.int"),os.path.join(work_dir,"txt.phseq.data.int"),"1","0",feat_dir,"ft",mod_dir,"0","0","0")

def align(args):
	bin_dir=os.path.join(args.ehmm_dir,"bin")
	feat_dir=os.path.join("ehmm","feat")
	mod_dir=os.path.join("ehmm","mod")
	work_dir=os.path.join("ehmm","etc")
	lab_dir=os.path.join("ehmm","lab")
	run(os.path.join(bin_dir,"edec"),os.path.join(work_dir,"ph_list.int"),os.path.join(work_dir,"txt.phseq.data.int"),"1",feat_dir,"ft",os.path.join(work_dir,"mysp_settings"),mod_dir,"0",lab_dir)
	run("perl",os.path.join(bin_dir,"sym2nm.pl"),lab_dir,os.path.join(work_dir,"ph_list.int"))

def fix(args):
	stops=set()
	doc=xml.parse(args.phoneset)
	for elem in doc.iterfind("phoneme"):
		if elem.get("vc")=="-":
			if elem.get("ctype") in ["s","a"]:
				stops.add(elem.get("name"))
	src_lab_dir=os.path.join("ehmm","lab")
	lab_file_list=sorted(name for name in os.listdir(src_lab_dir) if name.endswith(".lab"))
	labs=dict()
	stop_durs=collections.defaultdict(list)
	for base_name in lab_file_list:
		labs[base_name]=list()
		full_name=os.path.join(src_lab_dir,base_name)
		with codecs.open(full_name,"r","utf-8") as f_in:
			f_in.readline()
			prev_time=0.0
			for line in f_in:
				fields=line.split()
				if fields:
					phone=fields[-1]
					time=float(fields[0])
					dur=time-prev_time
					labs[base_name].append((phone,dur))
					if phone in stops:
						stop_durs[phone].append(dur)
					prev_time=time
	min_ssil_plus_stop=dict()
	for phone,durs in stop_durs.iteritems():
		min_ssil_plus_stop[phone]=stats.scoreatpercentile(durs,95)
	for base_name,phones in labs.iteritems():
		with codecs.open(os.path.join("lab",base_name),"w","utf-8") as f_out:
			f_out.write("#\n")
			time=0.0
			n=len(phones)
			for i,fields in enumerate(phones):
				dur=fields[-1]
				time+=dur
				phone=fields[0]
				next_phone = None if i==(n-1) else phones[i+1][0]
				skip=False
				if phone=="ssil":
					if next_phone in stops:
						next_dur=phones[i+1][-1]
						if (dur+next_dur) < min_ssil_plus_stop[next_phone]:
							skip=True
				elif phone=="pau" and next_phone=="pau":
					skip=True
				if not skip:
					f_out.write(u"{} 125 {}\n".format(time,"pau" if phone=="ssil" else phone))

def all(args):
	setup(args)
	phseq(args)
	feats(args)
	bw(args)
	align(args)
	fix(args)

if __name__=="__main__":
	parser=argparse.ArgumentParser(description="Label a speech database using the Ehmm labeller")
	parser.add_argument("--ehmm-dir",required=True,help="the path to the Ehmm labeller")
	parser.add_argument("--wave-dir",required=True,help="the path to the recordings")
	parser.add_argument("--transcription",required=True,help="the path to the transcription")
	parser.add_argument("--phoneset",required=True,help="phoneset")
	subparsers=parser.add_subparsers()
	setup_parser=subparsers.add_parser("setup")
	setup_parser.set_defaults(func=setup)
	phseq_parser=subparsers.add_parser("phseq")
	phseq_parser.set_defaults(func=phseq)
	feats_parser=subparsers.add_parser("feats")
	feats_parser.set_defaults(func=feats)
	bw_parser=subparsers.add_parser("bw")
	bw_parser.set_defaults(func=bw)
	align_parser=subparsers.add_parser("align")
	align_parser.set_defaults(func=align)
	fix_parser=subparsers.add_parser("fix")
	fix_parser.set_defaults(func=fix)
	all_parser=subparsers.add_parser("all")
	all_parser.set_defaults(func=all)
	args=parser.parse_args()
	args.func(args)
