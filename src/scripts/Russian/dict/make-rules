#!/usr/bin/python2
# -*- coding: utf-8; mode: Python; indent-tabs-mode: t; tab-width: 4; python-indent: 4 -*-

# Copyright (C) 2012  Olga Yakovleva <yakovleva.o.v@gmail.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import codecs
import collections

if __name__=="__main__":
	lex=dict()
	with codecs.open(sys.argv[1],"r","utf-8") as f:
		for line in f:
			pron=line.strip()
			if u"Ñ‘" not in pron:
				if sum(1 for c in pron if c.isupper())==1:
					n=next(i for i in xrange(len(pron)) if pron[i].isupper())+1
					lex["#"+pron.lower()+"#"]=n
	print(u"Using {} words for creating rules".format(len(lex)))
	data=collections.defaultdict(list)
	for word,n in lex.iteritems():
		for i in xrange(len(word)):
			for j in xrange(i+1,len(word)+1):
				data[word[i:j]].append(n-i)
	rules0=list()
	for substring,stress_positions in data.iteritems():
		if len(stress_positions)==1:
			continue
		if len(set(stress_positions))!=1:
			continue
		n=stress_positions[0]
		if n>=0 and n<len(substring):
			rules0.append((substring,n))
	print("{} initial rules".format(len(rules0)))
	del data
	rules0.sort(key=lambda p: len(p[0]))
	rules1=dict()
	for string,n in rules0:
		accept=True
		for i in xrange(n+1):
			for j in xrange(n+1,len(string)+1):
				substring=string[i:j]
				if substring in rules1:
					accept=False
					break
			if not accept:
				break
		if accept:
			rules1[string]=n
	print("{} rules after the first reduction".format(len(rules1)))
	del rules0
	print("Starting the second reduction")
	rules2=dict()
	words_to_rules=collections.defaultdict(set)
	rules_to_words=collections.defaultdict(set)
	active_words=set()
	active_rules=collections.Counter()
	for word,n in lex.iteritems():
		for i in xrange(n+1):
			for j in xrange(n+1,len(word)+1):
				substring=word[i:j]
				if rules1.get(substring,None)==n-i:
					words_to_rules[word].add(substring)
					active_words.add(word)
					rules_to_words[substring].add(word)
					active_rules[substring]+=1
	while active_words:
		best_rule,best_count =active_rules.most_common(1)[0]
		rules2[best_rule]=rules1[best_rule]
		words=rules_to_words[best_rule].intersection(active_words)
		active_words.difference_update(words)
		for word in words:
			word_rules=words_to_rules[word]
			active_rules.subtract(word_rules)
	print("{} rules after the second reduction".format(len(rules2)))
	with codecs.open(sys.argv[2],"w","utf-8") as f:
		for string,n in sorted(rules2.iteritems()):
			f.write(string[:n])
			f.write(string[n].upper())
			f.write(string[n+1:])
			f.write("\n")
