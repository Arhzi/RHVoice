#!/usr/bin/python2
# -*- coding: utf-8; mode: Python; indent-tabs-mode: t; tab-width: 4; python-indent: 4 -*-

# Copyright (C) 2012, 2015  Olga Yakovleva <yakovleva.o.v@gmail.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import codecs
import collections
import subprocess
import json

class prompt_selector(object):
	def __init__(self,conf):
		self.coverage_in_statements=conf["coverage_in_statements"]
		self.coverage_in_questions=conf["coverage_in_questions"]
		self.statements=set()
		self.questions=set()
		self.sentences=collections.OrderedDict()
		with codecs.open("sentences","r","utf-8") as f:
			for line in f:
				sentence=line.strip()
				if sentence:
					self.sentences[sentence]=list()
					if sentence.endswith("?") and self.coverage_in_questions>0:
						self.questions.add(sentence)
					else:
						self.statements.add(sentence)
   		self.determine_units()

	def reduce(self,candidates,coverage):
		if coverage==0:
			return set()
		result=set(candidates)
		cover=collections.Counter()
		for candidate in candidates:
			cover.update(self.sentences[candidate])
		target_cover=collections.Counter()
		for unit,count in cover.iteritems():
			target_cover[unit]=min(count,coverage)
		for candidate in candidates:
			units=self.sentences[candidate]
			cover.subtract(units)
			if (target_cover-cover):
				cover.update(units)
			else:
				result.remove(candidate)
		return result

	def __call__(self):
		statements=self.reduce(self.statements,self.coverage_in_statements)
		questions=self.reduce(self.questions,self.coverage_in_questions)
		result=list()
		for sentence in self.sentences.iterkeys():
			if (sentence in statements) or (sentence in questions):
				result.append(sentence)
		return result

class bigram_prompt_selector(prompt_selector):
	def __init__(self,conf):
		self.digraphs=set(conf["digraphs"])
		prompt_selector.__init__(self,conf)

	def get_word(self,token):
		ltoken=token.lower()
		if(ltoken[-1]).isalpha():
			return ltoken
		else:
			return ltoken[0:-1]

	def get_word_symbols(self,word):
		symbols=[]
		n=len(word)
		l=n-1
		i=0
		while (i<n):
			if i<l:
				b=word[i:i+2]
				if b in self.digraphs:
					symbols.append(b)
					i+=2
				else:
					symbols.append(word[i])
					i+=1
			else:
				symbols.append(word[i])
				i+=1
		return symbols

	def get_sentence_symbols(self,sentence):
			symbols=["#"]
			for token in sentence.split():
					word=self.get_word(token)
					symbols.extend(self.get_word_symbols(word))
					if not token[-1].isalpha():
							symbols.append("#")
			if symbols[-1]!="#":
					symbols.append("#")
			return symbols

	def get_n_grams(self,symbols,n):
		if len(symbols)<n:
			return []
		n_grams=[]
		for i in xrange(len(symbols)-n+1):
				n_grams.append(u"".join(symbols[i:i+n]))
		return n_grams

	def get_sentence_units(self,sentence):
		return self.get_n_grams(self.get_sentence_symbols(sentence),2)

	def determine_units(self):
		for sentence,units in self.sentences.iteritems():
			units.extend(self.get_sentence_units(sentence))

class diphone_prompt_selector(prompt_selector):
	def __init__(self,conf):
		self.language=conf["language"]
		self.infile="sentences"
		prompt_selector.__init__(self,conf)

	def determine_units(self):
		with codecs.open("ssml","w","utf-8") as f_out:
			f_out.write('<speak xml:lang="{}">\n'.format(self.language))
			for sentence in self.sentences.iterkeys():
				f_out.write(u"<s>{}</s>\n".format(sentence))
			f_out.write("</speak>\n")
		subprocess.check_call(["RHVoice-transcribe-sentences","ssml","transcription"])
		with codecs.open("transcription","r","utf-8") as f_in:
			for p,l in zip(self.sentences.iteritems(),f_in):
				phones=l.split()
				p[1].extend(phones[i-1]+"+"+phones[i] for i in xrange(1,len(phones)))

def select_prompts(conf):
	sel=diphone_prompt_selector(conf) if conf["language"] else bigram_prompt_selector(conf)
	prompts=sel()
	with codecs.open("prompts","w","utf-8") as f:
		for prompt in prompts:
			f.write(prompt)
			f.write("\n\n")
	words=set()
	for prompt in prompts:
		words.update((word[:-1] if word[-1] in [",",".","?"] else word).lower() for word in prompt.split())
	with codecs.open("vocab","w","utf-8") as f:
		for word in sorted(words):
			f.write(word)
			f.write("\n")

if __name__=="__main__":
	parser=argparse.ArgumentParser(description="Select prompts for recording")
	parser.add_argument("--config",required=True,help="the path to the configuration file")
	args=parser.parse_args()
	with open(args.config,"r") as f:
		conf=json.load(f)
	select_prompts(conf)
