#!/usr/bin/python2
# -*- mode: Python; indent-tabs-mode: t; tab-width: 4; python-indent: 4 -*-

# Copyright (C) 2012  Olga Yakovleva <yakovleva.o.v@gmail.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import argparse
import os
import os.path
import struct
import subprocess
import math

praat_script=os.path.join(os.path.abspath(os.path.dirname(sys.argv[0])),"print-pitch.praat")
rapt_command="sox {f} -t raw -|x2x +sf|pitch -a 0 -o 1 -L {l} -H {h} -s {s} -p {p}"
swipe_command="sox {f} -t raw -|x2x +sf|pitch -a 1 -o 1 -L {l} -H {h} -s {s} -p {p} -t {v}"

def extract_with_praat(file_name,args):
	return map(float,subprocess.check_output(["praat",praat_script,file_name,args.lower_f0,args.upper_f0,args.praat_voicing_threshold,"no"]).split())

def extract_with_rapt(file_name,args):
	sr=int(subprocess.check_output(["soxi","-r",file_name]))
	output=subprocess.check_output(rapt_command.format(f=file_name,l=args.lower_f0,h=args.upper_f0,s=sr/1000,p=sr/200),shell=True)
	count=len(output)/4
	return struct.unpack("={}f".format(count),output)

def extract_with_swipe(file_name,args):
	sr=int(subprocess.check_output(["soxi","-r",file_name]))
	output=subprocess.check_output(swipe_command.format(f=file_name,l=args.lower_f0,h=args.upper_f0,s=sr/1000,p=sr/200,v=args.swipe_voicing_threshold),shell=True)
	count=len(output)/4
	return struct.unpack("={}f".format(count),output)

def extract_and_vote(file_name,args):
	values1=extract_with_praat(file_name,args)
	values2=extract_with_rapt(file_name,args)
	values3=extract_with_swipe(file_name,args)
	values=list()
	for candidates in zip(values1,values2,values3):
		values.append(sorted(candidates)[1])
	return values

if __name__=="__main__":
	arg_parser=argparse.ArgumentParser(description="Calculate log-f0 values using voting method")
	arg_parser.add_argument("--wave-dir",required=True,help="the path to the recordings")
	arg_parser.add_argument("--out-dir",required=True,help="the output directory")
	arg_parser.add_argument("--lower-f0",required=True,help="lower f0")
	arg_parser.add_argument("--upper-f0",required=True,help="upper f0")
	arg_parser.add_argument("--method",required=False,help="extraction method",choices=["praat","rapt","swipe","vote"],default="vote")
	arg_parser.add_argument("--praat-voicing-threshold",required=False,help="praat voicing threshold",default="0.45")
	arg_parser.add_argument("--swipe-voicing-threshold",required=False,help="swipe voicing threshold",default="0.3")
	args=arg_parser.parse_args()
	audio_dir=os.path.abspath(args.wave_dir)
	lf0_dir=os.path.abspath(args.out_dir)
	try:
		os.mkdir(lf0_dir)
	except OSError:
		pass
	for base_name in sorted(os.listdir(audio_dir)):
		print base_name
		full_name=os.path.join(audio_dir,base_name)
		if args.method=="praat":
			values=extract_with_praat(full_name,args)
		elif args.method=="rapt":
			values=extract_with_rapt(full_name,args)
		elif args.method=="swipe":
			values=extract_with_swipe(full_name,args)
		else:
			values=extract_and_vote(full_name,args)
		with open(os.path.join(lf0_dir,os.path.splitext(base_name)[0]+".lf0"),"wb") as f:
		 	for f0 in values:
				if f0==0:
					lf0=-10000000000.0
				else:
					lf0=math.log(f0)
				f.write(struct.pack("=f",lf0))
