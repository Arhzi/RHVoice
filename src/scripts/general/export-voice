#!/usr/bin/python2
# -*- coding: utf-8; mode: Python; indent-tabs-mode: t; tab-width: 4; python-indent: 4 -*-

# Copyright (C) 2016  Olga Yakovleva <yakovleva.o.v@gmail.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import os.path
import json
import collections
import shutil
import subprocess
import imp
from struct import pack

voice_format="2"
numstates=5

def load_config(path):
	conf=collections.OrderedDict()
	if not os.path.isfile(path):
		return conf
	with open(path,"r") as f:
		for line in f:
			toks=line.strip().split("=")
			if not toks:
				continue
			conf[toks[0]]=toks[1]
	return conf

def save_config(conf,path):
	with open(path,"w") as f:
		for key,val in conf.iteritems():
			f.write(key)
			f.write("=")
			f.write(val)
			f.write("\n")

def save_info():
	path=os.path.join(outdir,"voice.info")
	info=load_config(path)
	name=settings["speaker"].title()
	if "name" in info:
		assert(name==info["name"])
	else:
		info["name"]=name
	if "language" not in info:
		info["language"]=settings["language"].title()
	info["sample_rate"]=str(settings["sample_rate"]//1000)+"k"
	if "gender" not in info:
		info["gender"]=settings["gender"].lower()
	format=info.get("format",0)
	revision=info.get("revision","0")
	if format==voice_format:
		revision=str(int(revision)+1)
	else:
		revision="0"
	info["format"]=voice_format
	info["revision"]=revision
	save_config(info,path)

def save_params():
	path=os.path.join(outdir,"voice.params")
	if os.path.isfile(path):
		return
	params=collections.OrderedDict([("beta","0.4"),("gain","1.0")])
	save_config(params,path)

def copy_voice():
	inpath=os.path.join("voices","qst001","ver1",settings["dataset"]+"_"+settings["speaker"]+".htsvoice")
	outpath=os.path.join(outdir,"voice.data")
	shutil.copy(inpath,outpath)

def make_conversion_config():
	path=os.path.join(outdir,"convert.conf")
	conf=collections.OrderedDict()
	conf["NATURALREADORDER"]="T"
	conf["NATURALWRITEORDER"]="F"
	save_config(conf,path)
	return path

def make_conversion_script(set,type):
	script_path=os.path.abspath(os.path.join(outdir,type+".hed"))
	tree_path=os.path.abspath(os.path.join("trees","qst001","ver1",set,type+".inf.untied"))
	with open(script_path,"w") as f:
		f.write("LT {}\n".format(tree_path))
		f.write("CT {}\n".format(outdir))
		f.write("CM {}\n".format(outdir))
	return script_path

def convert_model_and_tree(set,type,n,conf):
	hhed=os.path.join(settings["hts22_bindir"],"HHEd")
	mmf=os.path.abspath(os.path.join("models","qst001","ver1",set,"re_clustered.mmf"))
	script=make_conversion_script(set,type)
	lst=os.path.abspath(os.path.join("data","lists","full.list"))
	cmd=[hhed,"-B","-C",conf,"-T","2","-p","-i","-H",mmf,script,lst]
	subprocess.check_call(cmd)
	os.remove(script)
	os.rename(os.path.join(outdir,"trees.{}".format(n)),os.path.join(outdir,"tree-{}.inf".format(type)))
	os.rename(os.path.join(outdir,"pdf.{}".format(n)),os.path.join(outdir,"{}.pdf".format(type)))

def copy_windows(type,n):
	for i in xrange(1,n+1):
		file_name="{}.win{}".format(type,i)
		shutil.copy2(os.path.join("data","win",file_name),os.path.join(outdir,file_name))

def gen_lpf_pdf():
	makefilter=imp.load_source("makefilter",os.path.join("data","scripts","makefilter.py"))
	coefs=makefilter.lpf(settings["sample_rate"])
	numtaps=len(coefs)
	with open(os.path.join(outdir,"lpf.pdf"),"wb") as f:
		f.write(pack(">i",0))
		f.write(pack(">i",1))
		f.write(pack(">i",numtaps))
		for i in xrange(numstates):
			f.write(pack(">i",1))
		for i in xrange(numstates):
			for c in coefs:
				f.write(pack(">ff",c,0))

def gen_lpf_tree():
	with open(os.path.join(outdir,"tree-lpf.inf"),"w") as f:
		for i in xrange(2,numstates+2):
			f.write("{{*}}[{}]\n".format(i))
			f.write("   \"lpf_s{}_1\"\n".format(i))

def gen_lpf_win():
	with open(os.path.join(outdir,"lpf.win1"),"w") as f:
		f.write("1 1.0\n")

def convert_data():
	conf_path=make_conversion_config()
	convert_model_and_tree("cmp","mgc",1,conf_path)
	convert_model_and_tree("cmp","lf0",2,conf_path)
	convert_model_and_tree("dur","dur",1,conf_path)
	os.remove(conf_path)
	copy_windows("mgc",3)
	copy_windows("lf0",3)
	gen_lpf_pdf()
	gen_lpf_tree()
	gen_lpf_win()

if __name__=="__main__":
	with open("training.cfg","r") as f:
		settings=json.load(f)
	outdir=os.path.abspath(settings["outdir"])
	if not os.path.isdir(outdir):
		os.mkdir(outdir)
	save_info()
	save_params()
	copy_voice()
	convert_data()
