#!/usr/bin/python2
# -*- coding: utf-8; mode: Python; indent-tabs-mode: t; tab-width: 4; python-indent: 4 -*-

# Copyright (C) 2012  Olga Yakovleva <yakovleva.o.v@gmail.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import os.path
import xml.etree.ElementTree as xml
import argparse
import collections
import re
import itertools

phoneme_questions=None

class hts_feature(object):
	def __init__(self,name,prefix,suffix):
		self.name=name
		self.prefix=prefix
		self.suffix=suffix
		if prefix:
			format_string="*"+prefix
			pattern=".+"+re.escape(prefix)
		else:
			format_string=""
			pattern="^"
		format_string+="{}"
		pattern+="([a-zA-Z0-9]+)"
		if suffix:
			format_string+=(suffix+"*")
			pattern+=(re.escape(suffix)+".+")
		else:
			pattern+="$"
		self.format_string=format_string
		self.regex=re.compile(pattern)

	def extract_value(self,label):
		return self.regex.match(label).group(1)

def generate_phoneme_questions(file_path):
	feature_set=collections.defaultdict(lambda: collections.defaultdict(set))
	phoneme_set=set()
	doc=xml.parse(file_path)
	for elem in doc.iterfind("phoneme"):
		name=elem.get("name")
		for key,val in elem.items():
			if key!="name":
				feature_set[key][val].add(name)
				phoneme_set.add(name)
	for feature,values in feature_set.iteritems():
		values[None]=phoneme_set
	feature_names=sorted(feature_set.iterkeys())
	value_table=[feature_set[name].keys() for name in feature_names]
	groups=collections.OrderedDict()
	for values in itertools.product(*value_table):
		if all(value is None for value in values):
			continue
		group=set(phoneme_set)
		for name,value in zip(feature_names,values):
			group&=feature_set[name][value]
		group=tuple(group)
		if len(group)>1:
			if group not in groups:
				question_name="&&".join("{}=={}".format(name,value) for name,value in zip(feature_names,values) if value is not None)
				groups[group]=question_name
	return groups

def load_hts_features(file_path):
	features=collections.OrderedDict()
	doc=xml.parse(file_path)
	prefix=""
	for elem in doc.find("format").iterfind("feature"):
		name=elem.get("name")
		suffix=elem.tail.strip()
		features[name]=hts_feature(name,prefix,suffix)
		prefix=suffix
	return features

def extract_values(hts_features,label_dir):
	values=collections.defaultdict(set)
	for fname in os.listdir(label_dir):
		if fname.endswith(".lab"):
			with open(os.path.join(label_dir,fname),"rb") as f:
				for line in f:
					label=line.split()[-1]
					for name,feature in hts_features.iteritems():
						value=feature.extract_value(label)
						try:
							value=int(value)
						except ValueError:
							pass
						values[name].add(value)
	return values

def write_feature_questions(f_out,feature,values):
	for value in sorted(values):
		f_out.write('QS "{}=={}"\t{{{}}}\n'.format(feature.name,value,feature.format_string.format(value)))
	f_out.write("\n")
	m=re.match("^((?:prev_)*|(?:next_)*)name$",feature.name)
	if m:
		for phonemes,question in phoneme_questions.iteritems():
			f_out.write('QS "{}{}"\t{{{}}}\n'.format(m.group(1),question,",".join(feature.format_string.format(phoneme) for phoneme in phonemes)))
		f_out.write("\n")
	else:
		real_values=sorted(v for v in values if v!="x")
		if real_values and all(isinstance(v,int) for v in real_values) and (real_values[-1]>1):
			min_val=min(1,min(real_values))
			for v in real_values:
				lesser_values=["x"] if "x" in values else list()
				lesser_values.extend(xrange(min_val,v+1))
				f_out.write('QS "{}<={}"\t{{{}}}\n'.format(feature.name,v,",".join(feature.format_string.format(i) for i in lesser_values)))
			f_out.write("\n")

if __name__=="__main__":
	arg_parser=argparse.ArgumentParser(description="Generate questions for training an hts voice")
	arg_parser.add_argument("--phoneme-set",required=True,help="the path to the phoneme set description file")
	arg_parser.add_argument("--label-description",required=True,help="the path to the label description file")
	arg_parser.add_argument("--labels",required=True,help="the path to the full context labels")
	args=arg_parser.parse_args()
	phoneme_questions=generate_phoneme_questions(args.phoneme_set)
	hts_features=load_hts_features(args.label_description)
	all_values=extract_values(hts_features,args.labels)
	with open("questions_qst001.hed","wb") as f_out:
		for name,feature in hts_features.iteritems():
			values=all_values[name]
			write_feature_questions(f_out,feature,values)
	with open("questions_utt_qst001.hed","wb") as f_out:
		for name in ["num_syls_in_utt","num_words_in_utt","num_phrases_in_utt"]:
			feature=hts_features[name]
			values=all_values[name]
			write_feature_questions(f_out,feature,values)
