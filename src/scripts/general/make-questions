#!/usr/bin/python2
# -*- coding: utf-8; mode: Python; indent-tabs-mode: t; tab-width: 4; python-indent: 4 -*-

# Copyright (C) 2012  Olga Yakovleva <yakovleva.o.v@gmail.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import os.path
import xml.etree.ElementTree as xml
import argparse
import collections
import re
import itertools
import weakref

class phonetic_feature_table(object):
	def __init__(self):
		self._tier_names=list()
		self._tiers=dict()
		self._phonemes=set()

	def tag(self,phoneme,tier_name,feature):
		self._phonemes.add(phoneme)
		if tier_name in self._tiers:
			tier=self._tiers[tier_name]
		else:
			tier=collections.OrderedDict()
			self._tiers[tier_name]=tier
			self._tier_names.append(tier_name)
		if feature in tier:
			tier[feature].add(phoneme)
		else:
			phonemes=set()
			phonemes.add(phoneme)
			tier[feature]=phonemes

	def number_of_tiers(self):
		return len(self._tier_names)

	def tier_name(self,index):
		return self._tier_names[index-1]

	def tier_features(self,index):
		return ([None]+self._tiers[self.tier_name(index)].keys())

	def phonemes_with_feature(self,tier_index,feature):
		if feature is None:
			return self._phonemes
		else:
			return self._tiers[self.tier_name(tier_index)][feature]

class phonetic_class(object):
	def __init__(self,feature_table=None,parent=None,feature=None):
		if feature_table is not None:
			self.feature_table=feature_table
			self.parent=None
			self.feature=None
			self.level=0
		else:
			self.feature_table=parent.feature_table
			self.feature=feature
			self.level=parent.level+1
			self.parent=weakref.proxy(parent)
		self.children=list()

	def phonemes(self):
		if self.parent is None:
			return self.feature_table.phonemes_with_feature(1,None)
		else:
			return self.parent.phonemes().intersection(self.feature_table.phonemes_with_feature(self.level,self.feature))

	def name(self):
		if self.parent is None:
			return ""
		else:
			parent_name=self.parent.name()
			if self.feature is None:
				return parent_name
			else:
				s="{}=={}".format(self.feature_table.tier_name(self.level),self.feature)
				if parent_name:
					return "{}&&{}".format(parent_name,s)
				else:
					return s

	def is_null(self):
		node=self
		while node is not None:
			if node.feature is not None:
				return False
			node=node.parent
		return True

	def expand(self):
		for feature in self.feature_table.tier_features(self.level+1):
			child=phonetic_class(parent=self,feature=feature)
			if len(child.phonemes())>1:
				self.children.append(child)

phonetic_questions=None

class hts_feature(object):
	def __init__(self,name,prefix,suffix):
		self.name=name
		self.prefix=prefix
		self.suffix=suffix
		if prefix:
			format_string="*"+prefix
			pattern=".+"+re.escape(prefix)
		else:
			format_string=""
			pattern="^"
		format_string+="{}"
		pattern+="([a-zA-Z0-9]+)"
		if suffix:
			format_string+=(suffix+"*")
			pattern+=(re.escape(suffix)+".+")
		else:
			pattern+="$"
		self.format_string=format_string
		self.regex=re.compile(pattern)

	def extract_value(self,label):
		return self.regex.match(label).group(1)

def build_phonetic_feature_table(file_path):
	feature_table=phonetic_feature_table()
	doc=xml.parse(file_path)
	for elem in doc.iterfind("phoneme"):
		name=elem.get("name")
		for key,val in elem.items():
			if key!="name":
				feature_table.tag(name,key,val)
	return feature_table

def generate_phonetic_questions(file_path):
	feature_table=build_phonetic_feature_table(file_path)
	number_of_tiers=feature_table.number_of_tiers()
	questions=dict()
	root=phonetic_class(feature_table=feature_table)
	unvisited=collections.deque()
	unvisited.append(root)
	while unvisited:
		node=unvisited.popleft()
		if node.level==number_of_tiers:
			if not node.is_null():
				phonemes=tuple(sorted(node.phonemes()))
				if phonemes not in questions:
					questions[phonemes]=node.name()
		else:
			node.expand()
			unvisited.extend(node.children)
	return collections.OrderedDict(sorted(questions.iteritems(),key=lambda p: len(p[0]),reverse=True))

def load_hts_features(file_path):
	features=collections.OrderedDict()
	doc=xml.parse(file_path)
	prefix=""
	for elem in doc.find("format").iterfind("feature"):
		name=elem.get("name")
		suffix=elem.tail.strip()
		features[name]=hts_feature(name,prefix,suffix)
		prefix=suffix
	return features

def extract_values(hts_features,label_dir):
	values=collections.defaultdict(set)
	for fname in os.listdir(label_dir):
		if fname.endswith(".lab"):
			with open(os.path.join(label_dir,fname),"rb") as f:
				for line in f:
					label=line.split()[-1]
					for name,feature in hts_features.iteritems():
						value=feature.extract_value(label)
						try:
							value=int(value)
						except ValueError:
							pass
						values[name].add(value)
	return values

def write_feature_questions(f_out,feature,values):
	m=re.match("^((?:prev_)*|(?:next_)*)name$",feature.name)
	if m:
		for phonemes,question in phonetic_questions.iteritems():
			f_out.write('QS "{}{}"\t{{{}}}\n'.format(m.group(1),question,",".join(feature.format_string.format(phoneme) for phoneme in phonemes)))
		f_out.write("\n")
	for value in sorted(values):
		f_out.write('QS "{}=={}"\t{{{}}}\n'.format(feature.name,value,feature.format_string.format(value)))
	f_out.write("\n")
	if not m:
		real_values=sorted(v for v in values if v!="x")
		if real_values and all(isinstance(v,int) for v in real_values) and (real_values[-1]>1):
			min_val=min(1,min(real_values))
			for v in real_values:
				lesser_values=["x"] if "x" in values else list()
				lesser_values.extend(xrange(min_val,v+1))
				f_out.write('QS "{}<={}"\t{{{}}}\n'.format(feature.name,v,",".join(feature.format_string.format(i) for i in lesser_values)))
			f_out.write("\n")

if __name__=="__main__":
	arg_parser=argparse.ArgumentParser(description="Generate questions for training an hts voice")
	arg_parser.add_argument("--phoneme-set",required=True,help="the path to the phoneme set description file")
	arg_parser.add_argument("--label-description",required=True,help="the path to the label description file")
	arg_parser.add_argument("--labels",required=True,help="the path to the full context labels")
	args=arg_parser.parse_args()
	phonetic_questions=generate_phonetic_questions(args.phoneme_set)
	hts_features=load_hts_features(args.label_description)
	all_values=extract_values(hts_features,args.labels)
	with open("questions_qst001.hed","wb") as f_out:
		for name,feature in hts_features.iteritems():
			values=all_values[name]
			write_feature_questions(f_out,feature,values)
	with open("questions_utt_qst001.hed","wb") as f_out:
		for name in ["num_syls_in_utt","num_words_in_utt","num_phrases_in_utt"]:
			feature=hts_features[name]
			values=all_values[name]
			write_feature_questions(f_out,feature,values)
